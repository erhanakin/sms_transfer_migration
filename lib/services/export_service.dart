import 'dart:convert';
import 'dart:io';
import 'package:path_provider/path_provider.dart';
import 'package:csv/csv.dart';
import 'package:excel/excel.dart';
import 'package:share_plus/share_plus.dart';
import 'package:intl/intl.dart';
import '../models/sms_model.dart';
import '../utils/constants.dart';
import '../utils/file_utils.dart';

class ExportService {
  static final ExportService _instance = ExportService._internal();
  factory ExportService() => _instance;
  ExportService._internal();

  /// Export SMS messages to specified format
  Future<String> exportSMS({
    required List<SMSMessage> messages,
    required ExportFormat format,
    String? customFileName,
  }) async {
    try {
      final fileName = customFileName ?? _generateFileName(format);

      switch (format) {
        case ExportFormat.csv:
          return await _exportToCSV(messages, fileName);
        case ExportFormat.xlsx:
          return await _exportToXLSX(messages, fileName);
        case ExportFormat.json:
          return await _exportToJSON(messages, fileName);
        case ExportFormat.txt:
          return await _exportToTXT(messages, fileName);
      }
    } catch (e) {
      throw Exception('Failed to export SMS: $e');
    }
  }

  /// Export to CSV format
  Future<String> _exportToCSV(List<SMSMessage> messages, String fileName) async {
    try {
      final List<List<String>> csvData = [];

      // Add headers
      csvData.add(SMSMessage.csvHeaders());

      // Add message data
      for (final message in messages) {
        csvData.add(message.toCsvRow());
      }

      // Convert to CSV string
      final csvString = const ListToCsvConverter().convert(csvData);

      // Write to file
      final file = await _writeToFile(fileName, csvString);
      return file.path;
    } catch (e) {
      throw Exception('Failed to export to CSV: $e');
    }
  }

  /// Export to XLSX format
  Future<String> _exportToXLSX(List<SMSMessage> messages, String fileName) async {
    try {
      final excel = Excel.createExcel();
      final sheet = excel['SMS_Messages'];

      // Add headers
      final headers = SMSMessage.csvHeaders();
      for (int i = 0; i < headers.length; i++) {
        sheet.cell(CellIndex.indexByColumnRow(columnIndex: i, rowIndex: 0))
            .value = TextCellValue(headers[i]);
      }

      // Add message data
      for (int rowIndex = 0; rowIndex < messages.length; rowIndex++) {
        final message = messages[rowIndex];
        final rowData = message.toCsvRow();

        for (int colIndex = 0; colIndex < rowData.length; colIndex++) {
          sheet.cell(CellIndex.indexByColumnRow(
            columnIndex: colIndex,
            rowIndex: rowIndex + 1,
          )).value = TextCellValue(rowData[colIndex]);
        }
      }

      // Auto-fit columns
      for (int i = 0; i < headers.length; i++) {
        sheet.setColumnAutoFit(i);
      }

      // Save to file
      final bytes = excel.encode();
      if (bytes != null) {
        final file = await _writeBytesToFile(fileName, bytes);
        return file.path;
      } else {
        throw Exception('Failed to encode Excel file');
      }
    } catch (e) {
      throw Exception('Failed to export to XLSX: $e');
    }
  }

  /// Export to JSON format
  Future<String> _exportToJSON(List<SMSMessage> messages, String fileName) async {
    try {
      final exportData = {
        'export_info': {
          'exported_at': DateTime.now().toIso8601String(),
          'total_messages': messages.length,
          'app_name': AppConstants.appName,
          'app_version': AppConstants.version,
        },
        'messages': messages.map((message) => message.toExportJson()).toList(),
      };

      // Convert to formatted JSON string
      final jsonString = const JsonEncoder.withIndent('  ').convert(exportData);

      // Write to file
      final file = await _writeToFile(fileName, jsonString);
      return file.path;
    } catch (e) {
      throw Exception('Failed to export to JSON: $e');
    }
  }

  /// Export to TXT format
  Future<String> _exportToTXT(List<SMSMessage> messages, String fileName) async {
    try {
      final buffer = StringBuffer();

      // Add header
      buffer.writeln('SMS MESSAGES EXPORT');
      buffer.writeln('===================');
      buffer.writeln('Exported on: ${DateFormat('yyyy-MM-dd HH:mm:ss').format(DateTime.now())}');
      buffer.writeln('Total messages: ${messages.length}');
      buffer.writeln('Generated by: ${AppConstants.appName} v${AppConstants.version}');
      buffer.writeln();

      // Add messages
      for (int i = 0; i < messages.length; i++) {
        buffer.writeln('MESSAGE ${i + 1}/${messages.length}');
        buffer.write(messages[i].toTextFormat());
        buffer.writeln();
      }

      // Add footer
      buffer.writeln('===================');
      buffer.writeln('END OF EXPORT');

      // Write to file
      final file = await _writeToFile(fileName, buffer.toString());
      return file.path;
    } catch (e) {
      throw Exception('Failed to export to TXT: $e');
    }
  }

  /// Write string content to file
  Future<File> _writeToFile(String fileName, String content) async {
    final directory = await _getExportDirectory();
    final file = File('${directory.path}/$fileName');
    return await file.writeAsString(content);
  }

  /// Write bytes to file
  Future<File> _writeBytesToFile(String fileName, List<int> bytes) async {
    final directory = await _getExportDirectory();
    final file = File('${directory.path}/$fileName');
    return await file.writeAsBytes(bytes);
  }

  /// Get export directory
  Future<Directory> _getExportDirectory() async {
    final directory = await getApplicationDocumentsDirectory();
    final exportDir = Directory('${directory.path}/SMS_Exports');

    if (!await exportDir.exists()) {
      await exportDir.create(recursive: true);
    }

    return exportDir;
  }

  /// Generate file name based on format
  String _generateFileName(ExportFormat format) {
    final timestamp = DateFormat('yyyyMMdd_HHmmss').format(DateTime.now());
    final extension = FileExtensions.extensions[format];
    return 'SMS_Export_$timestamp$extension';
  }

  /// Share exported file
  Future<void> shareExportedFile(String filePath) async {
    try {
      final file = File(filePath);
      if (await file.exists()) {
        await Share.shareXFiles(
          [XFile(filePath)],
          text: 'SMS Export from ${AppConstants.appName}',
        );
      } else {
        throw Exception('Export file not found');
      }
    } catch (e) {
      throw Exception('Failed to share file: $e');
    }
  }

  /// Get all exported files
  Future<List<FileInfo>> getExportedFiles() async {
    try {
      final directory = await _getExportDirectory();
      final files = await directory.list().toList();

      final List<FileInfo> fileInfos = [];

      for (final file in files) {
        if (file is File) {
          final stat = await file.stat();
          final fileName = file.path.split('/').last;

          fileInfos.add(FileInfo(
            name: fileName,
            path: file.path,
            size: stat.size,
            createdAt: stat.changed,
            format: _getFormatFromFileName(fileName),
          ));
        }
      }

      // Sort by creation date (newest first)
      fileInfos.sort((a, b) => b.createdAt.compareTo(a.createdAt));

      return fileInfos;
    } catch (e) {
      throw Exception('Failed to get exported files: $e');
    }
  }

  /// Delete exported file
  Future<bool> deleteExportedFile(String filePath) async {
    try {
      final file = File(filePath);
      if (await file.exists()) {
        await file.delete();
        return true;
      }
      return false;
    } catch (e) {
      throw Exception('Failed to delete file: $e');
    }
  }

  /// Get export directory size
  Future<int> getExportDirectorySize() async {
    try {
      final directory = await _getExportDirectory();
      int totalSize = 0;

      await for (final file in directory.list()) {
        if (file is File) {
          final stat = await file.stat();
          totalSize += stat.size;
        }
      }

      return totalSize;
    } catch (e) {
      return 0;
    }
  }

  /// Clear all exported files
  Future<bool> clearAllExportedFiles() async {
    try {
      final directory = await _getExportDirectory();

      await for (final file in directory.list()) {
        if (file is File) {
          await file.delete();
        }
      }

      return true;
    } catch (e) {
      throw Exception('Failed to clear exported files: $e');
    }
  }

  /// Get format from file name
  ExportFormat _getFormatFromFileName(String fileName) {
    final extension = fileName.toLowerCase().split('.').last;

    switch (extension) {
      case 'csv':
        return ExportFormat.csv;
      case 'xlsx':
        return ExportFormat.xlsx;
      case 'json':
        return ExportFormat.json;
      case 'txt':
        return ExportFormat.txt;
      default:
        return ExportFormat.txt;
    }
  }

  /// Export messages in batches (for large datasets)
  Stream<ExportProgress> exportSMSInBatches({
    required List<SMSMessage> messages,
    required ExportFormat format,
    String? customFileName,
    int batchSize = 1000,
  }) async* {
    try {
      final fileName = customFileName ?? _generateFileName(format);
      final totalMessages = messages.length;
      final totalBatches = (totalMessages / batchSize).ceil();

      yield ExportProgress(
        current: 0,
        total: totalMessages,
        status: 'Preparing export...',
      );

      switch (format) {
        case ExportFormat.csv:
          yield* _exportCSVInBatches(messages, fileName, batchSize);
          break;
        case ExportFormat.json:
          yield* _exportJSONInBatches(messages, fileName, batchSize);
          break;
        default:
        // For XLSX and TXT, export all at once
          await exportSMS(messages: messages, format: format, customFileName: customFileName);
          yield ExportProgress(
            current: totalMessages,
            total: totalMessages,
            status: 'Export completed',
            filePath: (await _getExportDirectory()).path + '/$fileName',
          );
      }
    } catch (e) {
      yield ExportProgress(
        current: 0,
        total: messages.length,
        status: 'Export failed: $e',
        hasError: true,
      );
    }
  }

  /// Export CSV in batches
  Stream<ExportProgress> _exportCSVInBatches(
      List<SMSMessage> messages,
      String fileName,
      int batchSize,
      ) async* {
    final directory = await _getExportDirectory();
    final file = File('${directory.path}/$fileName');
    final sink = file.openWrite();

    try {
      // Write headers
      final headers = SMSMessage.csvHeaders();
      sink.writeln(const ListToCsvConverter().convert([headers]));

      yield ExportProgress(
        current: 0,
        total: messages.length,
        status: 'Writing headers...',
      );

      // Write messages in batches
      for (int i = 0; i < messages.length; i += batchSize) {
        final endIndex = (i + batchSize).clamp(0, messages.length);
        final batch = messages.sublist(i, endIndex);

        final batchData = batch.map((msg) => msg.toCsvRow()).toList();
        final csvBatch = const ListToCsvConverter().convert(batchData);

        sink.write(csvBatch);

        yield ExportProgress(
          current: endIndex,
          total: messages.length,
          status: 'Writing batch ${(i / batchSize).floor() + 1}...',
        );

        // Small delay to prevent blocking
        await Future.delayed(const Duration(milliseconds: 10));
      }

      await sink.close();

      yield ExportProgress(
        current: messages.length,
        total: messages.length,
        status: 'Export completed',
        filePath: file.path,
      );
    } catch (e) {
      await sink.close();
      throw e;
    }